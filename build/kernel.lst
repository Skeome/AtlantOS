     1                                  ;=================================================
     2                                  ; AtlantOS - Core Kernel (Simulated Ternary Logic)
     3                                  ;=================================================
     4                                  [BITS 32]
     5                                  [ORG 0x2000]                    ; We will load the kernel at 0x2000
     6                                  
     7                                  kernel_entry:
     8                                      ; Clear the Screen (simple loop)
     9 00000000 BF00800B00                  mov edi, 0xB8000
    10 00000005 B9D0070000                  mov ecx, 80 * 25
    11 0000000A 66B82007                    mov ax, 0x0720              ; Black background, white text, space character
    12 0000000E 66F3AB                      rep stosw
    13                                  
    14                                      ; Setup the "Ternary Test"
    15                                      ; Wee will start with a positive drift and watch it stabilize
    16 00000011 BE00000000                  mov esi, 0                  ; Initial Drift Value (0)
    17 00000016 BF00800B00                  mov edi, 0xB8000            ; Start Writing at top-left
    18                                  
    19                                      ; Call IDT
    20 0000001B E8C0000000                  call setup_idt
    21                                  
    22                                  kernel_loop:
    23                                      ; VISUALIZATION 
    24                                      ; We need to save registers because we are about to do math
    25 00000020 56                          push esi
    26 00000021 57                          push edi
    27                                  
    28                                      ; Reset render pointer to the start of the starus line
    29 00000022 BF00800B00                  mov edi, 0xB8000
    30                                  
    31                                      ; Clear the statul line (Erase the previous state)
    32 00000027 B950000000                  mov ecx, 80
    33 0000002C 66B82007                    mov ax, 0x0720              ; Space character with default color
    34 00000030 66F3AB                      rep stosw
    35                                  
    36                                      ; Reset Render Poionter again
    37 00000033 BF00800B00                  mov edi, 0xB8000
    38                                  
    39                                      ; Default character: 'X' (Zero/Locked)
    40 00000038 66B9580A                    mov cx, 0x0A58              ; 'X' character with Light Green color
    41 0000003C 83FE00                      cmp esi, 0
    42 0000003F 740D                        je .draw                    ; If zero, keep 'X'
    43                                  
    44                                      ; If not zero, assume negative first
    45 00000041 66B93C0C                    mov cx, 0x0C3C              ; '<' character with Light Red color
    46 00000045 83FE00                      cmp esi, 0
    47 00000048 7C04                        jl .draw                    ; If less than zero, keep '<'
    48                                  
    49                                      ;Must be positive
    50 0000004A 66B93E0E                    mov cx, 0x0E3E
    51                                  
    52                                  .draw:
    53                                     ; Render the state bar (Visualizing the magnitude of error)
    54                                     ; We map the value in ESI to a position on the screen
    55 0000004E 89F3                       mov ebx, esi                 ; Copy drift value
    56 00000050 83FB00                     cmp ebx, 0
    57 00000053 7D02                       jge .abs_calc
    58 00000055 F7DB                       neg ebx                      ; Get |abs| if negative
    59                                  
    60                                  .abs_calc:
    61                                      ; If stable (0), draw single indicator
    62 00000057 83FB00                      cmp ebx, 0
    63 0000005A 7505                        jne .render_loop
    64 0000005C 66890F                      mov [edi], cx               ; Write character and color into memory
    65 0000005F EB0E                        jmp .update_labels
    66                                      
    67                                  .render_loop:
    68 00000061 83FB00                      cmp ebx, 0
    69 00000064 7409                        je .update_labels
    70 00000066 66890F                      mov [edi], cx               ; Write status char+color
    71 00000069 83C702                      add edi, 2                  ; Move to the next screen cell
    72 0000006C 4B                          dec ebx
    73 0000006D EBF2                        jmp .render_loop
    74                                  
    75                                  .update_labels:
    76                                      ; Kernel Status Messages
    77                                  
    78 0000006F BFA0800B00                  mov edi, 0xB80A0            ; Move to start of line 2 (row 1, col 0)
    79                                  
    80 00000074 83FE00                      cmp esi, 0
    81 00000077 7516                        jne .status_correcting
    82                                  
    83                                      ; Status STABLE (Cyan)
    84 00000079 C707530B540B                mov dword [edi], 0x0B540B53     ; TS ---> ST
    85 0000007F C74704410B420B              mov dword [edi+4], 0x0B420B41   ; BA ---> AB
    86 00000086 C747084C0B450B              mov dword [edi+8], 0x0B450B4C   ; EL ---> LE
    87 0000008D EB14                        jmp .ternary_logic
    88                                  
    89                                  .status_correcting:
    90                                      ; Status ACTIVE (Red - Kernel is working)
    91 0000008F C707410C430C                mov dword [edi], 0x0C430C41     ; CA ---> AC
    92 00000095 C74704540C490C              mov dword [edi+4], 0x0C490C54   ; IT ---> TI
    93 0000009C C74708560C450C              mov dword [edi+8], 0x0C450C56   ; EV ---> VE
    94                                  
    95                                  .ternary_logic:
    96 000000A3 5F                          pop edi
    97 000000A4 5E                          pop esi
    98                                  
    99                                      ; Ternary Scheduler Logic
   100                                      ; Kernel automatically seeks equilibrium (0)
   101                                      ; In the full OS, this logic will balance load between cores
   102                                  
   103 000000A5 83FE00                      cmp esi, 0
   104 000000A8 7411                        je .cycle_delay
   105                                  
   106                                      ; Branchless Ternary Operator
   107                                      ; Direction = sign(ESI)
   108 000000AA 31DB                        xor ebx, ebx
   109 000000AC 31D2                        xor edx, edx
   110 000000AE 83FE00                      cmp esi, 0
   111 000000B1 0F9FC3                      setg bl             ; BL = 1 if (+)
   112 000000B4 0F9CC2                      setl dl             ; DL = 1 if (-)
   113 000000B7 29D3                        sub ebx, edx        ; EBX = 1 or -1
   114                                  
   115 000000B9 29DE                        sub esi, ebx        ; Restore Equilibrium
   116                                  
   117                                  .cycle_delay
   117          ******************       warning: label `.cycle_delay' alone on a line without a colon might be in error [-w+label-orphan]
   118                                      ; Kernel Cycle Delay
   119 000000BB B900004000                  mov ecx, 0x00400000
   120                                  .wait:
   121 000000C0 E2FE                        loop .wait
   122                                  
   123 000000C2 E959FFFFFF                  jmp kernel_loop
   124                                  
   125                                  ; Include Drivers
   126                                      %include 'src/kernel/idt.asm'
     1                              <1>  ;====================================================
     2                              <1>  ; AtlantOS Interrupt Descriptor Table (IDT) & Drivers
     3                              <1>  ;====================================================
     4                              <1> 
     5                              <1>  ; 1. Interrupt Service Routine
     6                              <1>  ; This code runs automatically when a key is pressed
     7                              <1>  isr_keyboard:
     8 000000C7 60                  <1>     pushad                  ; Save all general-purpose registers
     9                              <1>     ; Acknowledge the hardware
    10 000000C8 E460                <1>     in al, 0x60             ; Read from keyboard controller
    11                              <1> 
    12                              <1>     ; Left Arrow ("inject negative entropy")
    13 000000CA 3C4B                <1>     cmp al, 0x4B
    14 000000CC 7505                <1>     jne .check_right
    15 000000CE 83EE05              <1>     sub esi, 5              ; "Inject Negative Entropy"
    16 000000D1 EB07                <1>     jmp .send_eoi
    17                              <1> 
    18                              <1> .check_right:
    19                              <1>     ; Right Arrow = "Positive Entropy"
    20 000000D3 3C4D                <1>     cmp al, 0x4D
    21 000000D5 7503                <1>     jne .send_eoi
    22 000000D7 83C605              <1>     add esi, 5              ; "Inject Negative Entropy"
    23                              <1> 
    24                              <1> .send_eoi:
    25                              <1>     ; Send End of Interrupt (EOI) signal to PIC
    26 000000DA B020                <1>     mov al, 0x20
    27 000000DC E620                <1>     out 0x20, al            ; Notify PIC that interrupt has been handled
    28 000000DE 61                  <1>     popad                   ; Restore all general-purpose registers
    29 000000DF CF                  <1>     iretd                   ; Return from interrupt
    30                              <1> 
    31                              <1> ; 2. IDT Setup and PIC Remap
    32                              <1> setup_idt:
    33                              <1>     ; A. Remap the PIC
    34                              <1>     ; The PIC maps IRQs 0-7 on INT 0x08-0x0F by default
    35                              <1>     ; This conflicts with CPU exceptions, so we remap them to 0x20-0x27
    36                              <1> 
    37                              <1>     ; ICW1: Initialize PICs
    38 000000E0 B011                <1>     mov al, 0x11
    39 000000E2 E620                <1>     out 0x20, al            ; Start initialization of PIC1 (Master)
    40 000000E4 E6A0                <1>     out 0xA0, al            ; Start initialization of PCI2 (Slave)
    41                              <1> 
    42                              <1>     ; ICW2: Set Vector Offsets
    43 000000E6 B020                <1>     mov al, 0x20            ; Master PIC vector offset starting at 0x20
    44 000000E8 E621                <1>     out 0x21, al
    45 000000EA B028                <1>     mov al, 0x28            ; Slave PIC vector offset starting at 0x28
    46 000000EC E6A1                <1>     out 0xA1, al
    47                              <1> 
    48                              <1>     ; ICW3: Setup cascading
    49 000000EE B004                <1>     mov al, 0x04            ; Tell Master PIC that Slave PIC is at IRQ2
    50 000000F0 E621                <1>     out 0x21, al
    51 000000F2 B002                <1>     mov al, 0x02            ; Tell Slave PIC its cascade identity
    52 000000F4 E6A1                <1>     out 0xA1, al
    53                              <1> 
    54                              <1>     ; ICW4: Set environment info
    55 000000F6 B001                <1>     mov al, 0x01            ; 8086/88 mode
    56 000000F8 E621                <1>     out 0x21, al
    57 000000FA E6A1                <1>     out 0xA1, al
    58                              <1> 
    59                              <1>     ; Mask all interrupts except keyboard
    60 000000FC B0FD                <1>     mov al, 0xFD            ; 1111 1101 (Bit 1 is clear --> Keyboard Enabled)
    61 000000FE E621                <1>     out 0x21, al
    62 00000100 B0FF                <1>     mov al, 0xFF            ; Mask all on Slave PIC
    63 00000102 E6A1                <1>     out 0xA1, al
    64                              <1> 
    65                              <1>     ; B. Populate IDT Entry for keyboard (INT 0x21)
    66                              <1>     ; IRQ1 is mapped to INT 0x21 after remap
    67                              <1> 
    68 00000104 B8[C7000000]        <1>     mov eax, isr_keyboard   ; Get address of our handler
    69 00000109 66A3[29020000]      <1>     mov [idt_entry_21 + 0], ax      ; Lower 16 bits of address
    70 0000010F C1E810              <1>     shr eax, 16
    71 00000112 66A3[2F020000]      <1>     mov [idt_entry_21 + 6], ax      ; Upper 16 bits of address
    72                              <1> 
    73                              <1>     ; C. Load IDT
    74 00000118 0F011D[31020000]    <1>     lidt [idt_descriptor]
    75                              <1> 
    76                              <1>     ; D. Enable Interrupts
    77 0000011F FB                  <1>     sti                     ; Set Interrupt Flag (CPU will listen to interrupts)
    78 00000120 C3                  <1>     ret
    79                              <1> 
    80                              <1> ; 3. IDT Data Structures
    81                              <1> idt_start:
    82                              <1>     ; We need space for at least 34 interrupts (0x00 to 0x21)
    83                              <1>     ; To keep it simple, we define a block of empty entries
    84                              <1>     ; and manually define the specific ones we need
    85 00000121 0000000000000000-   <1>     times 0x21 dq 0         ; Empty entries up to INT 0x20
    85 00000121 <rep 21h>           <1>
    86                              <1> 
    87                              <1> ; Keyboard Interrupt Entry
    88                              <1> idt_entry_21:
    89 00000229 0000                <1>     dw 0x0000               ; Offset Low
    90 0000022B 0800                <1>     dw 0x0008               ; Selector (Kernel Code Segment = 0x08)
    91 0000022D 00                  <1>     db 0x00                 ; Unused, set to 0
    92 0000022E 8E                  <1>     db 10001110b            ; Type and Attributes: Present, Ring 0, 32-bit interrupt gate
    93 0000022F 0000                <1>     dw 0x0000               ; Offset High
    94                              <1> 
    95                              <1> idt_end:
    96                              <1> 
    97                              <1> idt_descriptor:
    98 00000231 0F01                <1>     dw idt_end - idt_start - 1  ; Limit (Size of IDT - 1)
    99 00000233 [21010000]          <1>     dd idt_start                ; Base address of IDT
